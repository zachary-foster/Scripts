library(reshape2)
library(ggplot2)
library(igraph)
library(png)
library(grid)
library(spider)
library(tools)
library(Hmisc)
library(knitr)
library(xtable)
library(plyr)
library(plotrix)

mycircle <- function(coords, v=NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size  <- 1/200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  vertex.frame.color <- params("vertex", "frame.color")
  if (length(vertex.frame.color) != 1 && !is.null(v)) {
    vertex.frame.color <- vertex.frame.color[v]
  }
  vertex.frame.width <- params("vertex", "frame.width")
  if (length(vertex.frame.width) != 1 && !is.null(v)) {
    vertex.frame.width <- vertex.frame.width[v]
  }
  
  mapply(coords[,1], coords[,2], vertex.color, vertex.frame.color,
         vertex.size, vertex.frame.width,
         FUN=function(x, y, bg, fg, size, lwd) {
           symbols(x=x, y=y, bg=bg, fg=fg, lwd=lwd,
                   circles=size, add=TRUE, inches=FALSE)
         })
}
add.vertex.shape("fcircle", 
                 plot=mycircle, 
                 parameters=list(vertex.frame.color=1, vertex.frame.width=1))

taxon_edge_list <- function(taxonomy, separator) {
  get_taxon_edge_list <- function(taxon) {
    apply(matrix(c(1:(length(taxon)-1),2:length(taxon)), ncol = 2), 1, function(x) c(taxon[x[1]], taxon[x[2]]))
  }
  taxons <- strsplit(taxonomy, separator, fixed=TRUE)
  taxons <- lapply(taxons, function(x) sapply(seq(1, length(x)), function(y) paste(x[1:y], collapse=separator)))
  edge_list <- t(do.call(cbind,lapply(taxons, FUN=get_taxon_edge_list)))
  edge_list[!duplicated(edge_list),]
}

get_edge_parents <-function(graph) {
  get.edges(graph, 1:ecount(graph))[,1]
}

get_edge_children <- function(graph) {
  get.edges(graph, 1:ecount(graph))[,2]
}

add_alpha <- function(col, alpha=1){
  apply(sapply(col, col2rgb)/255, 2,
        function(x)
          rgb(x[1], x[2], x[3], alpha=alpha))
}

get_vertex_children <- function(graph, vertex) {
  which(shortest.paths(graph, V(graph)[vertex], mode="out") != Inf)
}

offset_ordered_factor <- function(ordered_factor, offset) { 
  my_levels <-  levels(ordered_factor)
  new_level <- my_levels[which(my_levels == ordered_factor) + offset]
  ordered(new_level, my_levels)
}

fapply <- function(iterable, functions, 
                   .preprocessor={function(x) x},
                   .preprocessor_args=list(),
                   .allow_complex=TRUE,
                   ...) {
  apply_functions <- function(input, functions, ...) {
    if (!is.list(input)) {
      input <- list(input)
    }
    input <- append(input, list(...))
    results <- lapply(functions, function(f) do.call(f, input))
    atomics <- which(!sapply(results, is.recursive))
    if (length(atomics) > 0) {
      results[atomics] <- lapply(1:length(atomics), function(i) {y <- list(results[[atomics[i]]]); 
                                                                 names(y) <- functions[i];
                                                                 y})
    }
    results <- unlist(results, recursive=FALSE)
    if (!.allow_complex) {
      results <- results[!sapply(results, is.recursive)]
    }
    return(results)
  }
  if (length(iterable) < 1) {
    return(NULL)
  }
  if (is.data.frame(iterable) | is.matrix(iterable)) {
    iterable_length <- length(iterable[[1]])    
    row_names <- row.names(iterable)
    call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[i,]), .preprocessor_args))}
  } else if (is.list(iterable)) {
    iterable_length <- length(iterable)
    row_names <- unlist(iterable)
    call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[[i]]), .preprocessor_args))}    
  } else {
    iterable_length <- length(iterable)
    row_names <- iterable
    call_preprocessor <- function(i) {do.call(.preprocessor, append(list(iterable[i]), .preprocessor_args))}        
  }
  output <- lapply(1:iterable_length, function(i) apply_functions(call_preprocessor(i), functions, ...))
  column_names <- names(output[[1]])
  output <- lapply(1:length(output[[1]]), function(i) lapply(output, function(row) row[[i]]))
  output <- lapply(output, function(x) if (!is.recursive(x[[1]])) {unlist(x, recursive=FALSE)} else {I(x)})
  output <- do.call(data.frame, output)
  colnames(output) <- column_names
  row.names(output) <- row_names
  return(output)
}

filter_taxonomy_string <- function(taxon, min_level, max_level, taxon_levels) {
  parsed_taxonomy <- sapply(unlist(strsplit(taxon, split=';', fixed=T)),
                            strsplit, split='__', fixed=T)
  filter <- sapply(parsed_taxonomy, function(x) ordered(x[1], taxon_levels) >= min_level & ordered(x[1], taxon_levels) <= max_level)
  parsed_taxonomy <- parsed_taxonomy[filter]
  paste(sapply(parsed_taxonomy, paste, collapse='__'), collapse=';')
}

subsample_by_taxonomy <- function(distance_matrix, taxon, taxon_level, level_order, triangular=TRUE, level_to_analyze = 'subtaxon', max_subset=NA) {
  base_level <- offset_ordered_factor(taxon_level, 1)
  if (level_to_analyze == 'subtaxon') {
    level_to_analyze <- base_level
  }
  
  #if the level is not applicable return NA
  if (is.na(level_to_analyze) || taxon_level >= level_to_analyze) {
    return(NA)
  }
  
  #get indexes where taxon is present 
  indexes <- grep(taxon, row.names(distance_matrix), value = FALSE, fixed = TRUE)
  if (!is.na(max_subset) && length(indexes) > max_subset) {  #if their are too many instances, randomly subsample
    indexes = sample(indexes, max_subset)
  }
  
  #subsample matrix
  submatrix <- distance_matrix[indexes, indexes, drop = FALSE]
  names <- row.names(submatrix)
  names <- mapply(FUN=filter_taxonomy_string, names, MoreArgs=list(base_level, level_to_analyze, level_order))
  row.names(submatrix) <- names
  colnames(submatrix) <- names
  if (triangular) {
    submatrix[upper.tri(submatrix, diag=TRUE)] <- NA
  }
  return(submatrix)
}

taxon_info <- function(identifications, level_order, separator=';') {
  split_taxonomy <- strsplit(identifications, separator, fixed=TRUE)
  taxonomy <- unlist(lapply(split_taxonomy, function(x) sapply(seq(1, length(x)), function(y) paste(x[1:y], collapse=separator))))
  counts <- table(taxonomy)
  taxon_names <- names(counts)
  counts <- as.vector(counts)
  taxon_level <- sapply(strsplit(taxon_names, separator, fixed=TRUE), 
                        function(x) level_order[max(match(sub("__.*$", "", x), level_order))])
  taxon_level <- ordered(taxon_level, level_order)
  taxon_short_names <- sapply(1:length(taxon_names), function(i) filter_taxonomy_string(taxon_names[i], taxon_level[i], taxon_level[i], level_order))
  taxon_short_names <- sub("^.*__", "", taxon_short_names)
  data.frame(row.names=taxon_names, 
             level=taxon_level, 
             name=taxon_short_names, 
             count=counts)
  
}

rm_ext <- function(file) {
  sub("[.][^.]*$", "", file, perl=TRUE)
}

next_incremental_file_number <-function(directory) {
  current_numbers <- as.integer(rm_ext(list.files(directory, no..=TRUE)))
  if (length(current_numbers) == 0) {
    current_numbers = 0
  }
  max(current_numbers) + 1
}

remove_all_na_rows <- function(input) {
  na_rows <- sapply(1:nrow(input), function(x) sum(!is.na(input[x,])) != 0)
  input[na_rows, ]
}

remove_outliers <- function(x, na.rm = TRUE, ...) {
  qnt <- quantile(x, probs=c(.01, .99), na.rm = na.rm, ...)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

delete_vetices_and_children <- function(graph, vertices) {
  #delete children
  vertices <- unlist(sapply(vertices, function(x) get_vertex_children(graph, x)))
  graph <- delete.vertices(graph, vertices)
  return(graph)
}

continuous_color_legend <- function(values, background="#00000000", ...) {
  #Extract Legend (http://stackoverflow.com/questions/12041042/how-to-plot-just-the-legends-in-ggplot2)
  g_legend<-function(a.gplot){ 
    tmp <- ggplot_gtable(ggplot_build(a.gplot)) 
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box") 
    legend <- tmp$grobs[[leg]] 
    return(legend)} 
  mid_point = (max(values) + min(values)) / 2
  label_points <- seq(min(values), max(values), length.out=7)
  labels <- as.character(signif(label_points, 2))
  full_plot <- qplot(x,y, colour=value, data=data.frame(x=1, y=1, value=values)) + 
    scale_colour_gradient2(breaks = label_points, labels = labels, midpoint=mid_point, ...) + 
    theme(legend.key.size = unit(5, "cm"), 
          legend.text = element_text(size=85),
          legend.title = element_text(size=85),
          legend.background = element_rect(fill = background))
  g_legend(full_plot)
}

which_median <- function(x) which.min(abs(x - median(x)))

which_middle <- function(x) {
  middle <- (max(x) + min(x)) / 2
  which.min(abs(x - middle))
}

plot_image_tree <- function(graph, image_file_paths, labels=NA, scaling=1, exclude=c(), root_index=1, label_color = "black", display=FALSE) {
  #store the distance of all verticies and edges from the root
  root <- V(graph)[root_index]
  vertex_depth <- sapply(get.shortest.paths(graph, from=root)$vpath, length)
  edge_depth <- vertex_depth[get_edge_parents(graph)]
  
  #set vertex graphing parameters
  V(graph)$size <- (log(scaling + .5) / max(log(scaling) + .5)) * 10
  if (is.na(labels)) {
    V(graph)$label.cex <- 0
  } else {
    V(graph)$label <- labels
    V(graph)$label.cex <- V(graph)$size * .05 + .15
    V(graph)$label.color <- label_color
  }
  V(graph)$alpha <- (max(vertex_depth)*1.5 - vertex_depth) / (max(vertex_depth)*1.5)
  V(graph)$raster_file <- image_file_paths #not used in disaply, but should be subset below
  
  #set edge graphing parameters
  E(graph)$width <- V(graph)$size[get_edge_children(graph)] * 5
  E(graph)$color <- sapply(((max(edge_depth)*4 - edge_depth) / (max(edge_depth)*4)) * .3,
                           function(x) rgb(red=.3,green=.3,blue=.3,alpha=x))
  
  #exclude specific verticies and their decendents from display
  graph <- delete_vetices_and_children(graph, exclude)
  
  #Calculate vertex layout
  graph_layout <- layout.reingold.tilford(graph, root = root_index, circular = TRUE)
  
  #Load vertex images 
  V(graph)$raster <- lapply(as.character(V(graph)$raster_file), readPNG)
  
  #plot graph
  my_plot <- plot(graph,
                  layout=graph_layout,
                  margin=0, 
                  vertex.label.dist=0,
                  vertex.label.degree=0,
                  vertex.label=labels,
                  edge.arrow.size =0,
                  vertex.shape="raster", 
                  vertex.size=V(graph)$size*1.5,
                  vertex.size2=V(graph)$size*1.5)
  if (display) {
    print(my_plot)
  }
  return(plot)
}

plot_value_tree <- function(graph, values, labels=NA, scaling=1, exclude=c(), root_index=1, label_color = "black", display=FALSE, fade=FALSE, legend_text="", value_range=c(0,1), highlight_outliers=TRUE, background="#00000000") {
  #store the distance of all verticies and edges from the root
  root <- V(graph)[root_index]
  vertex_depth <- sapply(get.shortest.paths(graph, from=root)$vpath, length)
  edge_depth <- vertex_depth[get_edge_parents(graph)]
  
  #set vertex graphing parameters
  V(graph)$size <- (log(scaling + .5) / max(log(scaling) + .5)) * 10
  if (is.na(labels)) {
    V(graph)$label.cex <- 0
  } else if (labels == TRUE) {
    V(graph)$label <- as.character(signif(values, 2))
    V(graph)$label.cex <- V(graph)$size * .45 + .15
    V(graph)$label.color <- label_color
  } else {
    V(graph)$label <- labels
    V(graph)$label.cex <- V(graph)$size * .45 + .15
    V(graph)$label.color <- label_color
  }
  if (fade == TRUE) {
    V(graph)$alpha <- (max(vertex_depth)*1.5 - vertex_depth) / (max(vertex_depth)*1.5)
  } else if (fade == FALSE) {
    V(graph)$alpha <- 1
  } else {
    V(graph)$alpha <- fade
  }
  V(graph)$values <- values
  
  #set edge graphing parameters
  E(graph)$width <- V(graph)$size[get_edge_children(graph)] * 5
  E(graph)$color <- sapply(((max(edge_depth)*4 - edge_depth) / (max(edge_depth)*4)) * .3,
                           function(x) rgb(red=.3,green=.3,blue=.3,alpha=x))
  
  #exclude specific verticies and their decendents from display
  graph <- delete_vetices_and_children(graph, exclude)
  
  #set vertex color
  color_values <- V(graph)$values
  value_range_quantile <- quantile(color_values, value_range, na.rm=TRUE)
  if (highlight_outliers) {
    outliers <- color_values < value_range_quantile[1] | color_values > value_range_quantile[2]
    V(graph)$frame.width <- ifelse(outliers, 25, .05)    
  }
  outliers <- color_values < value_range_quantile[1] | color_values > value_range_quantile[2]
  V(graph)$frame.width <- ifelse(outliers, 25, .05)
  color_values[color_values < value_range_quantile[1]] <- value_range_quantile[1]
  color_values[color_values > value_range_quantile[2]] <- value_range_quantile[2]
  V(graph)$color=mapply(add_alpha, 
                        color.scale(color_values, c(1,0,0), c(0,1,0), c(0,0,1), xrange=c(min(color_values), max(color_values))), 
                        alpha=V(graph)$alpha)
  
  #Calculate vertex layout
  graph_layout <- layout.reingold.tilford(graph, root = root_index, circular = TRUE)
  
  #Load vertex images 
  V(graph)$raster <- lapply(as.character(V(graph)$raster_file), readPNG)
  
  #plot graph
  my_plot <- plot(graph,
                  layout=graph_layout,
                  margin=0, 
                  vertex.label.dist=0,
                  vertex.label.degree=0,
                  edge.arrow.size =0,
                  vertex.shape="fcircle", 
                  vertex.frame.color='black')
  
  #Make legend (http://stackoverflow.com/questions/12041042/how-to-plot-just-the-legends-in-ggplot2)
  legend <- continuous_color_legend(color_values,
                                    low=V(graph)$color[which.min(color_values)], 
                                    mid=V(graph)$color[which_middle(color_values)], 
                                    high=V(graph)$color[which.max(color_values)],
                                    name=legend_text,
                                    background=background)  
  pushViewport(viewport(x=0.9, y=0.15))
  grid.draw(legend)
  
  if (display) {
    print(my_plot)
  }
  return(plot)
}


#Functions for calculating taxon-specific statiscs
taxon_output_path_preparation <- function(output_directory, sub_directory=NULL, name=NULL, id=NULL, level_name=NULL, ext="", ...) {
  #get directory path
  if (!is.null(sub_directory)) {
    output_directory <- file.path(output_directory, sub_directory, fsep = .Platform$file.sep)
  }
  #prepare output directory
  if (!file.exists(output_directory)) {
    dir.create(output_directory, recursive=TRUE)
  }  
  #get output file name
  file_name <- paste(c(as.character(level_name),
                       as.character(name),
                       as.character(id)),
                     collapse="_") 
  if (file_name == "") { #if file name information is NULL assume that files are incremental integers. 
    file_name = as.character(next_incremental_file_number(output_directory))
  }
  #add extension
  file_name <- paste(c(file_name,
                       ext),
                     collapse="") 
  file.path(output_directory, file_name, fsep = .Platform$file.sep)
} 

overall_statistics <- function(distance, ...) {
  if (!is.matrix(distance)) {
    return(list(distance_mean=NA, 
                distance_sd=NA,
                distance_count=NA,
                subsampled_count=NA))
  }
  if (sum(!is.na(distance)) == 0) { #if there are no values besides NA
    my_mean = NA
  } else {
    my_mean = mean(distance, na.rm=TRUE)
  }
  return(list(distance_mean=my_mean, 
              distance_sd=sd(distance, na.rm=TRUE),
              distance_count=sum(!is.na(distance)),
              subsampled_count=nrow(distance)))
}

intertaxon_statistics <- function(distance, identity=NULL, ...) {
  output <- list()
  
  if (is.null(identity)) {
    identity = sapply(rownames(distance), function(x) colnames(distance) == x)
  }
  
  is_valid_input <- length(identity) > 0 && length(table(identity)) == 2
  
  if (is_valid_input) {
    inter_data <- distance[!identity]
    output$intertaxon_distance_mean <- mean(inter_data, na.rm=TRUE)
    output$intertaxon_distance_sd <- sd(inter_data, na.rm=TRUE)
    output$intertaxon_distance_count <- sum(!is.na(inter_data))
  } else {
    output$intertaxon_distance_mean <- NA
    output$intertaxon_distance_sd <- NA
    output$intertaxon_distance_count <- NA
  }
  return(output)
}

intrataxon_statistics <- function(distance, identity=NULL, ...) {
  output <- list()
  
  if (is.null(identity)) {
    identity = sapply(rownames(distance), function(x) colnames(distance) == x)
  }
  
  is_valid_input <- length(identity) > 0 && length(table(identity)) == 2
  
  if (is_valid_input) {
    intra_data <- distance[identity]
    output$intrataxon_distance_count <- sum(!is.na(intra_data))
    if (output$intrataxon_distance_count == 0) {
      output$intrataxon_distance_mean <- NA
    } else {
      output$intrataxon_distance_mean <- mean(intra_data, na.rm=TRUE)
    }
    output$intrataxon_distance_sd <- sd(intra_data, na.rm=TRUE)
    output$subtaxon_count <- length(unique(rownames(distance)))
  } else {
    output$intrataxon_distance_mean <- NA
    output$intrataxon_distance_sd <- NA
    output$intrataxon_distance_count <- NA
    output$subtaxon_count <- NA
  }
  return(output)
}

distance_distribution <- function(distance, identity=NULL, distance_bin_width=0.001, output_file_path=NULL, ...) {
  output <- list()
  
  if (is.null(identity)) {
    identity = sapply(rownames(distance), function(x) colnames(distance) == x)
  }
  
  #Validate input data
  is_valid_input = is.matrix(distance) && sum(!is.na(distance)) > 0
  
  #Calculate distance distribution
  if (is_valid_input) {
    breaks <- seq(as.integer(min(distance, na.rm=TRUE) / distance_bin_width),
                  as.integer(max(distance, na.rm=TRUE) / distance_bin_width) + 1)
    breaks <- breaks * distance_bin_width
    total_hist <- hist(distance, plot=FALSE, breaks=breaks)
    distance_distribution <- data.frame(count_middle=total_hist$mids, total=total_hist$counts)
    if (length(unique(rownames(distance))) >= 2) {
      same_hist <- hist(distance[identity], plot=FALSE, breaks=breaks)
      different_hist <- hist(distance[!identity], plot=FALSE, breaks=breaks)
      distance_distribution <- cbind(distance_distribution, 
                                     same=same_hist$counts,
                                     different=different_hist$counts)
    }
  } else {
    distance_distribution <- NA
  }
  output$distance_distribution <- distance_distribution
  
  #write output data
  if (!is.null(output_file_path)) {
    if (is_valid_input) {
      if (file.info(output_file_path)$isdir) {
        file_path <- taxon_output_path_preparation(output_file_path, 
                                                   sub_directory=as.character(match.call()[[1]]),
                                                   ext=".txt",
                                                   ...)
      } else {
        file_path <- output_file_path
      }
      write.table(format(distance_distribution, scientific = FALSE) , file=file_path, sep="\t", quote=FALSE, row.names=FALSE)    
    } else {
      file_path <- NA
    }
    output$distance_distribution_file <- file_path
  }
  
  return(output)
}

threshold_optimization <- function(distance, threshold_resolution=0.001, output_file_path=NULL, ...) {
  output <- list()
  
  #Validate input data
  is_valid_input = length(unique(rownames(distance))) >= 2
  
  if (is_valid_input) {
    #convert lower tri matrix to full
    distance[upper.tri(distance, diag=TRUE)] <- t(distance)[upper.tri(distance, diag=TRUE)]
    diag(distance) <- 0    
    
    #Calulate threshold error rates
    min_x = 0
    max_x = quantile(distance, .8, na.rm=TRUE, type=3)
    threshold <- seq(min_x, max_x, by = threshold_resolution)
    statistics <- lapply(threshold, function(x) threshOpt(distance, row.names(distance), thresh = x))
    statistics <- ldply(statistics)
    colnames(statistics) <- c("threshold", "true_negative", "true_positive", "false_negative", "false_positive", "cumulative_error")
    output$optimal_error <- min(statistics$cumulative_error)
    optimal_index <- which(output$optimal_error == statistics$cumulative_error) 
    output$optimal_threshold <- mean(statistics[optimal_index,'threshold'], rm.na=TRUE)
    output$optimal_false_negative <- statistics[optimal_index[1],'false_negative']
    output$optimal_false_positive <- statistics[optimal_index[length(optimal_index)], 'false_positive']
    output$threshold_optimization <- statistics 
  } else {
    output$optimal_error <- NA
    output$optimal_threshold <- NA
    output$optimal_false_negative <- NA
    output$optimal_false_positive <- NA   
    output$threshold_optimization <- NA
  }
  
  
  #write output data
  if (!is.null(output_file_path)) {
    if (is_valid_input) {
      if (file.info(output_file_path)$isdir) {
        file_path <- taxon_output_path_preparation(output_file_path, 
                                                   sub_directory=as.character(match.call()[[1]]),
                                                   ext=".txt",
                                                   ...)
      } else {
        file_path <- output_file_path
      }
      write.table(format(statistics, scientific = FALSE), file=file_path, sep="\t", quote=FALSE, row.names=FALSE)    
    } else {
      file_path <- NA
    }
    output$threshold_optimization_file <- file_path
  }
  
  return(output)
}







calculate_barcode_statistics <- function(distance_matrix, taxonomy_levels,
                                         saved_output_path = getwd(),
                                         level_to_analyze = 's',
                                         distance_type = 'PID',
                                         max_sequences_to_compare = 100,
                                         distance_bin_width = 0.001,
                                         threshold_resolution = 0.001,
                                         return_raw_data = FALSE,
                                         #                                          remove_na_rows = TRUE,
                                         save_statistics = FALSE,
                                         save_raw_data = FALSE,
                                         save_plots = FALSE,
                                         taxonomy_separator = ';',
                                         functions_to_apply = list("overall_statistics",
                                                                   "intertaxon_statistics",
                                                                   "intrataxon_statistics",
                                                                   "distance_distribution",
                                                                   "threshold_optimization")) {
  
  
  #If the metric is similarity (ie 1=same instead of 0), convert to distance
  if (distance_matrix[1,1] == 1) {
    distance_matrix = 1 - distance_matrix
  }
  
  #Prepare output directory  
  output_prefix <-  paste(distance_type, '_', taxonomy_levels[level_to_analyze], sep='')
  if(save_raw_data) {
    raw_data_output_directory_name <- paste(output_prefix, '_raw_data', sep='')
    raw_data_output_directory <- file.path(saved_output_path, raw_data_output_directory_name, fsep = .Platform$file.sep)
    if (!file.exists(raw_data_output_directory)) {
      dir.create(raw_data_output_directory, recursive=TRUE)
    }
  } else {
    raw_data_output_directory = NULL    
  }
  
  #Calculate taxonomy statistics
  taxonomy_data <- taxon_info(distance_matrix_taxonomy, names(taxonomy_levels))
  taxonomy_data <- taxonomy_data[order(taxonomy_data$level), ]
  taxonomy_data$id <- 1:nrow(taxonomy_data)
  
  #apply functions to subsets of distance matrix for each taxon (CAN TAKE LONG TIME)
  get_stat_function_arguments <- function(data_frame_row, ...) {
    distance <- subsample_by_taxonomy(distance_matrix, row.names(data_frame_row), data_frame_row$level, names(taxonomy_levels), ...)
    list(distance,
         identity = sapply(rownames(distance), function(x) colnames(distance) == x),
         name = data_frame_row$name,
         id = data_frame_row$id,
         level_name = taxonomy_levels[data_frame_row$level])
  }
  
  taxon_statistics <- fapply(taxonomy_data, functions_to_apply,
                             .preprocessor = get_stat_function_arguments,
                             .preprocessor_args = list(level_to_analyze = level_to_analyze, 
                                                       max_subset = max_sequences_to_compare),
                             .allow_complex = return_raw_data,
                             output_file_path = raw_data_output_directory,
                             distance_bin_width = distance_bin_width,
                             threshold_resolution = threshold_resolution)
  taxon_statistics <- cbind(taxonomy_data, taxon_statistics)
  
  #   #Remove rows that are all NA 
  #   if (remove_na_rows) {
  #     taxon_statistics <- remove_all_na_rows(taxon_statistics)                          
  #   }
  
  #Calculate statistics derived from other statistics
  taxon_statistics$inter_intra_differnece <- taxon_statistics$intertaxon_distance_mean - taxon_statistics$intrataxon_distance_mean
  taxon_statistics$optimal_error <- (taxon_statistics$optimal_false_negative + taxon_statistics$optimal_false_positive) / taxon_statistics$subsampled_count
  
  if (save_statistics) {
    taxon_statistics_output_name = paste('taxon_statistics', '_', output_prefix, '.txt', sep='')
    taxon_statistics_output_path =  file.path(saved_output_path, taxon_statistics_output_name, fsep = .Platform$file.sep)
    complex_column <- sapply(taxon_statistics, is.recursive)
    write.table(taxon_statistics[,!complex_column], file=taxon_statistics_output_path, sep="\t", quote=FALSE, col.names=NA)
  }
  
  return(taxon_statistics)
}

